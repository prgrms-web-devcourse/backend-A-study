# Network | TCP 흐름제어, 혼잡제어


> TCP 신뢰성을 보장해주는 방법인 `흐름제어`, `혼잡제어`에 대해 설명한 글입니다. TCP에 관한 내용은 다음 글을 참고해주세요.
>
> - [Network | 전송 계층 (TCP, UDP)](https://velog.io/@soo5717/Transport-Layer)
> - [Network | TCP Handshaking](https://velog.io/@soo5717/TCP-Handshaking)



## 1. 흐름제어 (Flow Control)

> TCP 흐름제어는 전송 계층에서 데이터 패킷을 전송할 때 수신 한도를 넘는 과잉 패킷의 입력으로 패킷 분실이 일어나지 않도록 패킷의 흐름을 조절하는 기법이다. 
>
> - 송신 (호스트) <-> 수신 (호스트)

간단하게 설명하면 **송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법**이다. 즉, 수신 측에 받을 수 있는 한도를 넘어서는 패킷을 받지 않도록 조절하는 것이다. 

`송신 측 전송량 > 수신 측 처리량`일 경우 처리량을 넘어선 시점 이후 도착하는 데이터는 손실될 수 있으며, 손실될 경우 송/수신 측 간의 불필요한 전송과 응답이 빈번하게 발생한다. 그렇기에 이러한 위험을 줄이기 위해 송신 측과 수신 측의 데이터 전송량을 수신 측에 맞춰 조절하는 것이다.

### 정지 - 대기 : Stop and Wait

> 송신 측에서 매번 전송한 패킷에 대한 수신 측의 **확인 응답(ACK)을 받아야만 그다음 패킷을 전송하는 기법**이다.  
>
> - 하나를 주고 하나를 받는 방법이기 때문에 **비효율적인 방식**이다.

![263B7D4E5715ECEB32](https://raw.githubusercontent.com/soo5717/Typora-image/velog/img/263B7D4E5715ECEB32.png)

### 슬라이딩 윈도 : Sliding Window

> 수신 측에서 설정한 윈도의 크기만큼 송신 측에서 **확인 응답(ACK) 없이 전송할 수 있게 하여 흐름을 동적으로 제어하는 기법**이다.
>
> - 수신 측에서 제대로 수신한 바이트에 대한 확인 응답을 전송할 때마다 버퍼의 범위가 한꺼번에 이동한다.
> - 정지 - 대기 기법의 비효율성을 개선한 기법이다.

> 여기서 윈도(Window)는 호스트가 다른 호스트로부터 확인을 수신하기 전에 전송할 수 있는 버퍼의 범위이다.

![253F7E485715ED5F27](https://raw.githubusercontent.com/soo5717/Typora-image/velog/img/253F7E485715ED5F27.png)

윈도에 포함되는 패킷을 전송하고 그 패킷들의 전달이 확인되는 대로 윈도를 옆으로 옮기면서 다음 패킷을 전송한다. 

- 모든 호스트는 송신을 위한 윈도와 수신을 위한 윈도를 가지고 있다.
- 호스트들은 실제 데이터를 보내기 전에 `3 Way Handshaking`을 통해 송신 윈도 크기와 수신 윈도 크기를 맞춘다.

![transfer_window](https://raw.githubusercontent.com/soo5717/Typora-image/velog/img/transfer_window.png)

![receive_window](https://raw.githubusercontent.com/soo5717/Typora-image/velog/img/receive_window.png)

## 2. 혼잡제어 (Congestion Control)

> TCP 혼잡제어는 전송 계층에서 네트워크로 유입되는 사용자 트래픽의 양이 네트워크 용량을 초과하지 않도록 송신 측에서 ACK 수신 여부로 네트워크 상황을 판단, 송신 데이터 크기를 조절하여 혼잡 상황을 제어하는 기법이다.
>
> - 송신 (호스트) <-> 라우터 (네트워크)

혼잡 제어는 **송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법**이다.

송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.  때 한 라우터에 데이터가 몰리게 될 경우(혼잡할 경우) 라우터는 자신에게 온 모든 데이터를 처리할 수 없게 된다. 이런 경우 송신 측은 데이터를 재전송하게 되는데 이는 결국 혼잡을 가중하고 오버플로우 or 데이터 손실이 발생하게 된다. 

따라서 이러한 **네트워크의 혼잡을 피하고자 송신 측에서 데이터를 보내는 전송 속도를 강제로 줄이게 되는데 이러한 작업을 혼잡제어라고 한다.** 

흐름제어의 경우 송신 측과 수신 측 사이의 전송 속도를 다루었지만, 혼잡제어는 송신 측과 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다룬다.

![256E39425715F10103](https://raw.githubusercontent.com/soo5717/Typora-image/velog/img/256E39425715F10103.png)

### AIMD

> Additive Increase / Multiplicative Decrease. 합 증가 / 곱 감소라고도 불린다. 
>
> 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착할 경우 **윈도 크기를 1씩 증가시켜 가면서 전송**하는 방법이다. 만약 **패킷 전송에 실패하거나 일정 시간을 넘길 경우 패킷을 보내는 속도를 절반으로 줄인다.** 

공평한 방식으로 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다.

초기에는 네트워크의 높은 대역폭을 사용하지 못하기 때문에 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다는 문제점이 있다. **즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.**

### 느린 출발 : Slow Start

> 미리 정해진 임계치에 도달할 때까지 **원도의 크기를 2배씩 증가시킨다.**

AIMD 방식의 경우 네트워크 수용량 주변에서는 효율적으로 작동하지만 처음 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있었다.

느린 시작 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고 패킷이 문제없이 도착할 경우 각각의 ACK 패킷마다 윈도 사이즈를 1씩 늘려준다. **즉, 한 주기가 지나면 윈도 사이즈가 2배가 되기 때문에 선형적으로 증가하지 않고 지수적으로 증가한다.** 

대신 **혼잡현상이 발생할 경우는 윈도의 크기를 1로 떨어뜨리게 된다.** 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다. 그러므로 혼잡 현상이 발생했던 윈도 크기 절반까지는 지수로 윈도 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.

이때 전송되는 데이터 크기가 **임계 값에 도달할 경우 혼잡 회피 단계로 넘어간다.**

### 혼잡 회피 : Congestion Avoidance

> 느린 출발의 지수적 증가가 임계치에 도달하게 되면 혼잡으로 간주하고, 회피를 위해 주고받는 윈도 크기가 선형적으로 증가하여 혼잡을 예방한다.

윈도 크기가 임계 값에 도달한 이후에는 혼잡에 의해 데이터 손실이 발생할 확률이 높아지게 된다. 그렇기에 데이터를 전송하는 데 있어서 조심하는 단계이다. 

전송한 데이터에 대한 ACK를 받을 경우 **윈도 크기를 1씩 증가 시켜 나가면서 전송**하는 데이터 증가시킨다. 수신 측로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우, 타임아웃이 발생하고 네트워크에 혼잡이 발생했다고 인식한다. **이때, 윈도의 크기를 1로 줄이고, 임계 값을 패킷 손실이 발생하였을 때의 윈도 크기의 반으로 줄입니다.**

### 빠른 재전송 : Fast Retransmit

> 송신 측에서 3개의 중복 패킷을 받게 되면 해당 패킷이 손실되었다고 간주해 타임아웃을 기다리지 않고 즉시 재전송한다.

빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다. 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 때도 ACK 패킷을 보낸다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로 중간에 패킷 하나가 손실되게 되면 보내는 측에서는 순번이 중복된 ACK 패킷을 받게 되고, 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송해 줄 수 있다. **빠른 재전송은 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다.** 이런 현상이 일어나는 것은 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 윈도 크기를 줄이게 된다.

### 빠른 회복 : Fast Recovery

> 빠른 재전송 이후 느린 출발이 아닌 혼잡 회피 상태에서 선형적 전송을 하는 기법이다.

빠른 회복 정책은 **혼잡한 상태가 되면 윈도 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다.**  빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 합 증가/곱 감소 방식으로 동작하게 된다.

