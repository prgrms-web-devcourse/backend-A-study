### 정리글
---
|주차|제목|링크|
|---|---|---|
|4주차|컬렉션 API 개선|[링크](https://velog.io/@ljo_0920/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98-%EC%BB%AC%EB%A0%89%EC%85%98-API-%EA%B0%9C%EC%84%A0)|
| |리팩터링, 테스팅, 디버깅|[링크](https://velog.io/@ljo_0920/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98-%EB%A6%AC%ED%8C%A9%ED%84%B0%EB%A7%81-%ED%85%8C%EC%8A%A4%ED%8C%85-%EB%94%94%EB%B2%84%EA%B9%85)|

</br>

### 궁금증 및 회고록
---

컬렉션 API를 보면서 스트림과는 다른 목적으로 의도된 편리한 메서드들을 살펴볼 수 있어서 좋았다.
of로 생성되는 컬렉션들은 불변인 점도 처음 알게 되어 좋았고 이번 스터디를 통해서 ConcurrentHashMap의 메서드 같은 경우는 조금 더 살펴보아야할 필요성을 느꼈다.


</br>

또 람다, 스트림을 통한 리팩토링 챕터를 공부하면서 확실히 코드의 직관성을 한눈에 볼 수 있는점은 매우 강력한 기능인 것 같다. 남의 코드를 보며 무엇을 하려고 하는지를 이해하기 편한 것 같다.
또 람다쪽을 보면서 아무래도 익명 인스턴스(?)의 느낌이 강하므로 여러 로직이 섞인 부분은 확실히 메서드나 클래스로 빼는 것이 좋아 보여 모든 것을 람다로 바꿀 이유는 없어 보이고 람다는 공통 행위? 즉, 메서드를 파라미터로 던져줘서 유연성을 높이기에 정말 유용한 것 같다고 생각했다. 